import Keycloak from 'keycloak-js';
import { reactive, toRefs } from 'vue';

function isArray(value) {
    return Array.isArray(value);
}
function isFunction(fun) {
    return typeof fun === 'function';
}
function isNil(value) {
    return value === undefined || value === null;
}
function isString(value) {
    return typeof value === 'string';
}

const state = reactive({
    keycloak: undefined,
    isAuthenticated: false,
    hasFailed: false,
    error: null,
    isPending: false,
    token: '',
    decodedToken: {},
    username: '',
    userId: '',
    roles: [],
    resourceRoles: {},
});
const setKeycloak = (value) => {
    state.keycloak = value;
};
const setToken = (token, tokenParsed) => {
    state.token = token;
    const content = tokenParsed;
    state.decodedToken = content;
    state.roles = content.realm_access ? content.realm_access.roles : [];
    state.username = content.preferred_username;
    state.userId = content.sub;
    state.resourceRoles = content.resource_access
        ? Object.fromEntries(Object.entries(content.resource_access).map(([key, value]) => [key, value.roles]))
        : {};
};
const hasFailed = (value, err) => {
    state.hasFailed = value;
    if (err instanceof Error) {
        state.error = err;
    }
    else if (isString(err === null || err === void 0 ? void 0 : err.error)) {
        state.error = new Error(err.error);
    }
    else if (isString(err)) {
        state.error = new Error(err);
    }
    else {
        state.error = new Error('Unknown');
    }
    state.error.name = '[vue-keycloak]';
    console.error(state.error);
};
const isPending = (value) => {
    state.isPending = value;
};
const isAuthenticated = (value) => {
    state.isAuthenticated = value;
};

let $keycloak = undefined;
async function updateToken(minValidity) {
    try {
        await $keycloak.updateToken(minValidity);
        setToken($keycloak.token, $keycloak.tokenParsed);
        return $keycloak.token;
    }
    catch (err) {
        const rejectionReason = isNil(err) ? new Error('Failed to refresh the access token') : err;
        hasFailed(true, rejectionReason);
        throw rejectionReason;
    }
}
async function getToken(minValidity = 10) {
    return updateToken(minValidity);
}
function createKeycloak(config) {
    try {
        $keycloak = new Keycloak(config);
        setKeycloak($keycloak);
    }
    catch (err) {
        hasFailed(true, isNil(err) ? new Error('Failed to create the keycloak adapter') : err);
    }
    return $keycloak;
}
async function initKeycloak(initConfig) {
    try {
        isPending(true);
        const _isAuthenticated = await $keycloak.init(initConfig);
        isAuthenticated(_isAuthenticated);
        if (!isNil($keycloak.token)) {
            setToken($keycloak.token, $keycloak.tokenParsed);
        }
    }
    catch (err) {
        isAuthenticated(false);
        hasFailed(true, isNil(err) ? new Error('Failed to initialize the keycloak adapter') : err);
    }
    finally {
        isPending(false);
    }
}

const useKeycloak = () => {
    return {
        ...toRefs(state),
        hasRoles: (roles) => isArray(roles) && state.isAuthenticated && roles.every(role => state.roles.includes(role)),
        hasResourceRoles: (roles, resource) => isArray(roles) &&
            !isNil(resource) &&
            state.isAuthenticated &&
            !isNil(state.resourceRoles) &&
            isArray(state.resourceRoles[resource]) &&
            roles.every(role => state.resourceRoles[resource].includes(role)),
    };
};

const defaultInitConfig = {
    flow: 'standard',
    checkLoginIframe: false,
    onLoad: 'login-required',
};

const vueKeycloak = {
    install: async (app, options) => {
        if (isNil(options)) {
            hasFailed(true, new Error('The VueKeycloakPluginConfig is required'));
            return;
        }
        let keycloakPluginConfig;
        if (isFunction(options)) {
            keycloakPluginConfig = await options();
        }
        else {
            keycloakPluginConfig = options;
        }
        if (isNil(keycloakPluginConfig.config)) {
            hasFailed(true, new Error('The KeycloakConfig is required'));
            return;
        }
        const keycloakConfig = keycloakPluginConfig.config;
        const keycloakInitOptions = !isNil(keycloakPluginConfig.initOptions)
            ? { ...defaultInitConfig, ...keycloakPluginConfig.initOptions }
            : defaultInitConfig;
        const _keycloak = createKeycloak(keycloakConfig);
        if (isNil(_keycloak))
            return;
        app.config.globalProperties.$keycloak = _keycloak;
        await initKeycloak(keycloakInitOptions);
    },
};

export { getToken, useKeycloak, vueKeycloak };
//# sourceMappingURL=index.mjs.map
